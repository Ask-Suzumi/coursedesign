# G6-Chain：基于 C 语言的区块链模拟系统

> **致组员：**
> 本项目不仅仅是一个简单的记账程序，而是一个融合了**链表、队列、哈希算法、递归搜索、暴力枚举**等核心数据算法与结构课程概念的综合实践项目。
> 我们不依赖复杂的外部区块链库，而是从零开始，用最基础的 C 语言构建一个微型比特币网络，以加强对数据算法与结构课程内容理解的同时，了解区块链的基本架构模型；

---

## 1. 底层原理：为什么叫“区块链”？

在开始写代码前，我们需要理解这个系统的核心逻辑，它由三个基础概念支撑：

### 1.1 密码学指纹 (SHA-256)

* **原理**：任何数据（比如“A转给B 100块”），经过 SHA-256 算法计算后，都会变成一串唯一的 64 位字符（哈希值）。
* **特性**：只要数据改动哪怕一个标点符号，哈希值都会面目全非。
* **在本项目中**：我们用它来生成公钥、交易ID、以及区块的指纹，确保数据不可篡改。

### 1.2 链式结构 (The Chain)

* **原理**：每一个区块（Block）都记录了上一个区块的哈希值（`prev_hash`）。
* **后果**：如果你篡改了第 10 个块的数据，它的哈希变了；第 11 个块记录的 `prev_hash` 就不对了；以此类推，整条链都会断裂。
* **在本项目中**：我们使用**双向链表**来实现这一结构。

### 1.3 工作量证明 (PoW)

* **原理**：为了防止有人恶意快速生成区块，系统要求必须解出一道数学难题（找到一个随机数 `Nonce`，使得区块哈希以 `000` 开头）才能获得记账权。
* **在本项目中**：这就是**模块 D** 的核心任务——暴力循环计算。

---

## 2. 数据结构设计 (Data Structures)

为了模拟真实环境，我们设计了以下核心结构体。请在编码时严格参考 `g6chain_collab.c` 中的定义。

### 2.1 核心实体：区块 (Block)

这是最复杂的数据结构，采用**双向链表**组织。

```c
typedef struct Block {
    BlockHeader header;      // 区块头（元数据：哈希、时间戳、难度、Nonce）
    int tx_count;            // 交易数量
    Transaction txs[10];     // 交易列表（定长数组）
    char hash[65];           // 本区块的哈希缓存
    
    struct Block* next;      // 指向下一个块（用于正向遍历，如计算余额）
    struct Block* prev;      // 指向上一个块（用于反向递归，如资金溯源）
} Block;

```

### 2.2 辅助实体：矿工与用户 (MinerNode)

为了方便管理人员的加入和退出，我们使用**单向链表**。

```c
typedef struct MinerNode {
    char name[32];           // 矿工代号
    char pubkey[65];         // 公钥（钱包地址）
    struct MinerNode* next;  // 链表指针
} MinerNode;

```

* **设计理由**：人员数量是不定的，链表支持动态的 `malloc` 和 `free`，比数组更灵活。

### 2.3 缓冲池：内存池 (Mempool)

这是待打包交易的候车室，我们使用**数组模拟队列**。

```c
Transaction g_mempool[100]; 
int g_mempool_count;

```

* **设计理由**：交易在被打包前是暂时存放的，先进先出（FIFO）或优先级处理，数组实现简单且效率高。

---

## 3. 模块分工与算法逻辑

项目被拆分为 5 个核心模块，分别对应不同的算法知识点。请大家认领：

### 🟢 模块 A：矿工管理 (Linked List Ops)

* **核心任务**：实现 `MinerNode` 链表的增删改查。
* **算法考点**：
* **头插法** (`add_miner`)：`new_node->next = head; head = new_node;`
* **特定节点删除** (`delete_miner`)：这是链表操作的难点。你需要处理“删除头节点”和“删除中间节点”两种情况，维护 `prev` 指针以防断链。



### 🔵 模块 B：账本审计 (Traversal & Search)

* **核心任务**：计算某个人的余额，查找用户名对应的地址。
* **算法考点**：
* **全链遍历** (`get_balance`)：从创世块 (`g_head`) 开始，`while(curr != NULL)` 一直跑到末尾。每经过一个块，都要遍历里面的交易数组，做加减法。
* **线性查找**：在链表中比对字符串 (`strcmp`)。



### 🟠 模块 C：交易池调度 (Queue & Formatting)

* **核心任务**：接收用户的转账请求，放入 `g_mempool`。
* **算法考点**：
* **数据组装**：将发送方、接收方、金额、时间戳拼接成字符串。
* **默克尔根计算** (`calc_merkle_root`)：这不是树操作，而是简化版——将所有交易 ID 拼在一起做一次 Hash，代表本区块所有交易的唯一摘要。



### 🔴 模块 D：核心矿工 (Brute Force & Hashing)

* **核心任务**：也就是“挖矿”。
* **算法考点**：
* **暴力枚举算法**：写一个死循环 `while(1)`。
* 每一次循环，修改 `Nonce` 值，重新计算 Hash。
* 判断 Hash 是否满足条件（前导零检查）。
* **双向链表链接**：挖到后，将新块挂到链尾：`tail->next = new; new->prev = tail; tail = new;`。



### 🟣 模块 E：数据分析 (Recursion / DFS)

* **核心任务**：资金来源溯源。比如查“张三的钱哪来的？”
* **算法考点**：**递归 (Recursion)**。
* **终止条件**：追溯到了创世块，或者超过了 8 层深度。
* **递归逻辑**：如果在 Block N 发现李四转给张三 10 块，立即调用函数自身，去查 Block N 之前“李四的钱是哪来的”。



---

## 4. 快速开始 (Build & Run)

### 环境要求

* 任意 C 语言编译器 (GCC 推荐)。
* Windows/Mac/Linux 均可（代码已内置 Windows 乱码修复）。

### 编译命令

打开终端（Terminal/CMD），进入代码目录：

```bash
# 编译
gcc g6chain_collab.c -o g6chain

# 运行
./g6chain  (Windows下直接运行 g6chain.exe)

```

### 开发流程

1. 打开 `g6chain_collab.c`。
2. 搜索 `MODULE [你的模块号]`（例如 `MODULE A`）。
3. 删除占位用的 `TODO` 注释。
4. 根据注释提示编写代码。
5. 编译测试，确保没有报错。

---

## 5. 项目亮点 

1. **全流程模拟**：涵盖了从账户创建、交易入池、PoW 挖矿到区块上链的全过程。
2. **数据持久化**：实现了 `*.dat` 文件读写，程序重启后数据不丢失，模拟真实数据库。
3. **架构清晰**：完全按照“高内聚低耦合”设计，加密层、存储层、业务逻辑层分离。
4. **算法落地**：将课本上的链表、递归、哈希等抽象概念应用到了具体的业务场景中。

---
##项目结构图
### G6-Chain User System 项目架构图


！[image](Struct.svg)

### 架构分层详解

#### 1. 表现层 (Presentation Layer - CLI)

这一层负责与用户进行交互，接收输入并展示系统的状态。

* **核心组件**：`main` 函数中的主循环和 Switch 结构。
* **功能界面**：包含了登录注册 (`LoginUI`)、区块链浏览器 (`ExplorerUI`)、矿工管理界面 (`MinerUI`) 以及用户列表展示 (`UserListUI`)。它们只负责显示和收集数据，具体的处理逻辑委托给下一层。

#### 2. 核心业务逻辑层 (Core Business Logic Layer)

这是系统的“大脑”，包含所有区块链运行的规则。它被进一步细分为三个子模块：

* **A. 共识与挖矿引擎**：
* 负责维护区块链的生长。`AutoMineCheck` 在主循环中不断检测是否需要出块。
* `PoWLogic` 实现了简化的工作量证明，通过不断尝试 Nonce 来计算符合难度的区块哈希。
* `GenesisInit` 确保系统首次启动时创建创世区块。


* **B. 交易与钱包管理**：
* 处理资金的流动。`TxProcessor` 接收用户转账请求并生成交易 ID 放入内存池。
* `BalanceCalculator` 通过遍历整个区块链历史来计算任意用户的当前余额（UTXO 模型的简化版）。
* `TraceEngine` 实现了递归的资金溯源功能。


* **C. 账户与权限管理**：
* 管理系统中的用户身份。`AuthService` 处理登录时的密码校验（通过哈希比对）。
* `MinerMgr` 处理将普通用户升级为矿工或删除矿工的逻辑，确保逻辑闭环（如修复版中的升级校验）。
* `AddressResolver` 提供用户名到公钥的互相解析服务，方便 UI 显示。



#### 3. 数据模型层 (In-Memory Data Models)

这一层定义了系统运行时在内存中维护的数据结构（即代码中的全局变量和结构体定义）。

* **BlockchainList (双向链表)**：核心账本数据，使用双向链表方便正向遍历计算余额和反向回溯资金来源。
* **MempoolArray (数组队列)**：临时存储待打包的交易。
* **MinerList & ContactList (单向链表)**：分别存储具有挖矿权限的用户和所有已注册用户的名单，用于快速查找和鉴权。

#### 4. 基础设施层 (Infrastructure Layer)

提供最底层的通用服务支持。

* **加密组件 (Crypto Utils)**：核心的 `SHA256` 算法实现。它被业务逻辑层广泛调用，用于生成公私钥、计算交易 ID、计算区块哈希和默克尔根。
* **持久化存储 (Persistence)**：负责将内存中的数据模型序列化写入磁盘文件（`.dat`），或在系统启动时反序列化读取恢复状态，保证数据不丢失。


**Happy Coding! Let's build our own Blockchain! 🚀**

（声明：项目仅是对区块链技术的简单模拟以及数据结构与算法课程设计需要，仅供交流学习）
